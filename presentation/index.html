<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>GoroutIntro</title>

		<link rel="stylesheet" href="reveal.js/dist/reset.css">
		<link rel="stylesheet" href="reveal.js/dist/reveal.css">
		<link rel="stylesheet" href="reveal.js/dist/theme/moon.css">
	</head>
	<body>
        <div class="reveal">
            <div class="slides">

                <section>
                    <h2>GoroutIntro</h2>
                    <p>A poor man's introduction to goroutines</p>
                </section>

                <section>
                    <h2>Agenda</h2>
                    <ul>
                        <li class="fragment">Rationale</li>
                        <li class="fragment">Syntax</li>
                        <li class="fragment">Goroutines in action</li>
                        <li class="fragment">Comparision with Kotlin's coroutines</li>
                        <li class="fragment">Resources</li>
                    </ul>
                </section>

                <section> 
                    <h2>Why goroutines?</h2>
                    <ul>
                        <li>Solve C10K problem</li>
                        <li>Concurrency for the go eco system</li>
                        <li>Easy for developer to use</li>
                        <li>Lightweight in contrast to OS threads</li>
                        <li>Based on <em>continuations</em> from 1960s</li>
                    </ul>   
                </section>

                <section> 
                    <h2>What does that look like?</h2>
                    <p>You call a regular function, but prepend a
                    <code>go</code>
                    </p> 
                    <pre class="fragment"><code data-trim>
                         func f(s string){
                           ... 
                         }

                         func main() {
                           f("standard")
                           go f("goroutine")
                         }
                     </code></pre>
                </section>

                <section>
                    <h2>Any limitations?</h2>
                    <ul>
                        <li class="fragment">Upper limit for parallel number of goroutines</li>
                        <li class="fragment">Caller can't get return value</li>
                    </ul>
                    <pre class="fragment"><code data-trim> 
                         func f(s string) string {
                            ...
                         }

                         func main() {
                           // value := go f("goroutine") does not work
                           go f("goroutine")
                         }
                    </code></pre>
                </section>

                <section>
                    <h2>How to control goroutines?</h2>
                    <ul>
                        <li>Atomic counters</li>
                        <li>Mutexes</li>
                        <li>Channels</li>
                        <li>Select</li>
                        <li>Wait-/ErrGroups (we will have an example for that)</li>
                    </ul>
                </section>

                <section>
                    <h2>Atomic Counters</h2>
                    <pre><code data-trim>
                      // add value atomically
                      var counter uint64  
                      atomic.AddUint64(&counter, 1)

                      // read value atomically
                      readCounter := atomic.LoadUint64(&counter)
                    </code></pre>
                </section>

                <section>
                    <h2>Mutexes</h2>
                    <p>Used to protected shared state</p>
                    <pre><code data-trim>
                       mu sync.Mutex
                       importantString := ""
                       ...
                       func change(newValue string) {
                           mu.Lock()
                           defer mu.Unlock()
                           importantString = newValue
                       }
                    </code></pre>
                </section>

                <section>
                    <h2>Channels</h2>
                    <p>A Channel is structure that enables communication
                    between two different goroutines.
                    </p>
                    <pre class="fragment"><code data-trim>
                        func main() {
                            // declare channel
                            messages := make(chan string)
                            // send something to the channel
                            go func() { messages <- "ping" }()
                            // read something from the channel
                            msg := <-messages
                            fmt.Println(msg)
                        }
                   </code></pre>
                </section>
                <section>
                    <h2>Channels continued</h2>
                        <ul>
                            <li>Block by default until both sender and receiver
                            are ready</li>
                            <li class="fragment">Buffered channels do not block
                                on write access<pre>
                                <code data-trim>
                                     messages := make(chan string, 3)
                                </code></pre>
                            </li>
                        </ul>
                </section>

                <section>
                    <h2>Channel directions</h2>
                        <pre><code data-trim>
                            func pong(pings <-chan string, pongs chan<- string) {
                                msg := <-pings
                                pongs <- msg
                            }
                        </code></pre>
                </section>
                <section>
                    <h2>Select</h2>
                    <pre><code data-trim>
                    func doWork(c1: <-chan string, c2: <-chan string) {
                        go func() {
                            c1 <- "one"
                        }()
                        go func() {
                            c2 <- "two"
                        }()
                        for i := 0; i < 2; i++ {
                            select {
                                case msg1 := <-c1:
                                    fmt.Println("received", msg1)
                                case msg2 := <-c2:
                                    fmt.Println("received", msg2)
                            }
                        }
                    }
                    </code></pre>
                </section>

                <section>
                    <h2>WaitGroup/Channel sample</h2>
                    <ul>
                        <li>Analyze quality of Novatec's documentation of its
                        GitHub projects</li>
                        <li class="fragment">aka Download Readme and check size</li>
                    </ul>
                </section>

                <section>
                    <h2>Goroutines vs coroutines</h2>
                    <ul>
                        <li class="fragment">Share common concepts</li>
                        <li class="fragment">Lower level abstraction as coroutines</li>
                        <li class="fragment">Missing structured concurrency</li>
                        <li class="fragment"><code>async</code> is a simple way to return values from a coroutine</li>
                    </ul>
                </section>

                <section>
                    <h2>Summary</h2>
                    <ul>
                        <li class="fragment">Looks easy, but it ain't</li>
                        <li class="fragment">It is still pretty low level</li>
                        <li class="fragment">Beware: We haven't touched error
                            handling</li>
                        <li class="fragment">Beware: I have no battle proof
                            experience</li>
                    </ul>
                </section>

                <section>
                    <h2>Resources</h2>
                    <ul>
                        <li>Basic concepts (not go specific): <a href="https://www.youtube.com/watch?v=oV9rvDllKEg">
                                Concurrency is not Parallelism by Rob Pike</a></li>
                        <li>Detailed walkthrough of a goroutine: <a href="https://riteeksrivastava.medium.com/a-complete-journey-with-goroutines-8472630c7f5c">A
                            complete journey with Goroutines</a></li>
                        <li>Why Go?: <a href="https://dave.cheney.net/2015/08/08/performance-without-the-event-loop">Technical
                                details of goroutines</a></li>
                        <li>Code samples: <a href="https://gobyexample.com/">https://gobyexample.com</a></li>
                        <li>Standard library: <a href="https://pkg.go.dev/std">Go standard library</a></li>
                    </ul>
                </section>
            </div>
        </div>

		<script src="reveal.js/dist/reveal.js"></script>
		<script src="reveal.js/plugin/notes/notes.js"></script>
		<script src="reveal.js/plugin/markdown/markdown.js"></script>
		<script src="reveal.js/plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
